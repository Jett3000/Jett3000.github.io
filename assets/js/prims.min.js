var nodeNum=100,nodes=[],nodePool=[],currentNode=null,startTime=0;const primSketchNode=document.getElementById("prim-holder");function setup(){createCanvas(primSketchNode.clientWidth,primSketchNode.clientHeight).parent(primSketchNode),stroke(255),fill(255);for(let e=0;e<nodeNum;e++){let o=new Node(e);nodes.push(o),nodePool.push(o),o.show()}currentNode=random(nodePool),startTime=millis()}function draw(){if(nodePool.length>0)primStep();else{for(let e of nodes)e.inTree=!1,e.primParent=null,e.primWeight=1/0,nodePool.push(e);let e=millis()-startTime;print("Making and resetting tree took "+Math.round(e)/1e3+"s."),currentNode=random(nodePool),background(14,90),startTime=millis()}}function primStep(){null!=currentNode.primParent&&line(currentNode.pos.x,currentNode.pos.y,currentNode.primParent.pos.x,currentNode.primParent.pos.y),nodePool.splice(nodePool.indexOf(currentNode),1);let e=1/0,o=null;for(let t of nodePool){let r=manhattanDist(currentNode,t);r<t.primWeight&&(t.primParent=currentNode,t.primWeight=r),t.primWeight<=e&&(e=t.primWeight,o=t)}currentNode=o}function resetTree(){for(let e of nodes)e.primParent=null,e.primWeight=1/0,nodePool.push(e);currentNode=random(nodePool)}function nextNodeToAdd(e){let o=1/0,t=0;for(let r=0;r<e.length;r++)e[r].primWeight<o&&(o=e[r].primWeight,t=r);return e[t]}function manhattanDist(e,o){return dx=abs(e.pos.x-o.pos.x),dy=abs(e.pos.y-o.pos.y),(dy+dx)*random(.7,1.3)}class Node{constructor(e){this.code=e,this.pos=createVector(random(.05*width,.95*width),random(.05*height,.95*height)),this.primParent=null,this.primWeight=1/0,this.inTree=!1,this.beingAdded=!1}show(){ellipse(this.pos.x,this.pos.y,4,4)}}